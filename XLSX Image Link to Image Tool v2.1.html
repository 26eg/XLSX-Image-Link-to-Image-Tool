<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>XLSX 图片链接转图片工具 v2.1</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 40px auto;
            padding: 0 20px;
        }
        h1 {
            color: #1a73e8;
        }
        input[type="file"] {
            display: block;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        button {
            background-color: #1a73e8;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 1em;
			padding: 10px;
			border-radius: 5px;
        }
        button:disabled {
            background-color: #a0c3ff;
            cursor: not-allowed;
        }
		.button-container {
			display: flex;         /* 使用 Flexbox 布局 */
			align-items: center;   /* 垂直居中对齐内部元素（按钮和文字） */
			margin-bottom: 20px;   /* 将原本在按钮上的下外边距移到容器上 */
		}
		#noFileError {
			color: #d93025;        /* 设置字体为红色 */
			font-weight: bold;     /* 字体加粗 */
			margin-left: 15px;     /* 与左侧按钮保持15像素的间距 */
		}
        #status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            background-color: #f0f0f0;
            border-left: 5px solid #1a73e8;
            white-space: pre-wrap; /* 保持换行 */
            word-wrap: break-word;
        }
        #downloadLinkContainer a {
            display: inline-block;
            margin-top: 20px;
            padding: 12px 20px;
            background-color: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
        }
        .error {
            border-left-color: #d93025 !important;
            color: #d93025;
        }
        .warning {
            border-left-color: #ff9800 !important;
        }
        .success {
             border-left-color: #28a745 !important;
        }
    </style>
</head>
<body>

    <h1>XLSX 图片链接转图片工具 v2.1</h1>
    <p><strong>功能说明 (v2.1):</strong></p>
    <ol>
        <li>选择格式为 <code>.xlsx</code> 的源文件后，工具会读取第一个工作表的 <strong>B列</strong>。</li>
		<li>从第2行开始，如果B列单元格内容是图片链接 (http/https)，工具会下载该图片并将其作为浮动图片插入到该单元格的位置。</li>
		<li>处理完成后，会生成一个可供下载的新文件。<strong>所有操作均在您的浏览器本地化完成</strong>。</li>
		<li>处理还包括如下操作：</li>
		<ul>
			<li><strong>B列</strong>的超链接会转换为纯文本URL再进行处理。</li>
			<li><strong>B列</strong>的图片链接对应行的尺寸预设为约 <strong>3x3 厘米</strong>。</li>
			<li>图片会<strong>等比例缩放</strong>后，插入到对应单元格。</li>
			<li>处理完成后提供包含成功/失败计数的详细报告。</li>
			<li>生成的文件将自动<strong>冻结首行</strong>。</li>
			<li>下载文件名将自动包含处理日期和时间。</li>
		</ul>
    </ol>
    
    <!-- 1. 修改注意的内容 -->
    <p><strong>注意：</strong>如果图片链接本地网络环境无法访问，或图片服务器禁止跨域访问(CORS)，图片可能无法被下载。</p>

    <input type="file" id="fileInput" accept=".xlsx" />
	<!-- 使用一个容器来包裹按钮和错误提示，以便水平对齐 -->
    <div>
		<button id="processButton">开始处理</button>
		<span id="noFileError"></span>
	</div>
    <div id="status" style="display: none;"></div>
    <div id="downloadLinkContainer"></div>

    <!-- 引入 ExcelJS 库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>

    <script>
        // --- 全局变量定义：获取页面上的主要交互元素 ---
        const fileInput = document.getElementById('fileInput'); // 文件选择框
        const processButton = document.getElementById('processButton'); // “开始处理”按钮
        const statusDiv = document.getElementById('status'); // 显示状态和进度的区域
        const downloadLinkContainer = document.getElementById('downloadLinkContainer'); // 放置下载链接的容器

        // --- 事件监听器绑定 ---
        processButton.addEventListener('click', handleFileProcessing);

        // 4. 当选择了新的数据源后，清空之前的处理结果
        fileInput.addEventListener('change', () => {
            statusDiv.innerHTML = ''; // 清空状态信息
            statusDiv.style.display = 'none'; // 隐藏状态区域
            downloadLinkContainer.innerHTML = ''; // 清空下载链接
        });


        /**
         * @description 格式化当前日期时间为 YYYYMMDD HHMMSS 格式的字符串
         * @returns {string} 格式化后的日期时间字符串
         */
        function getFormattedDateTime() {
            const now = new Date();
            const YYYY = now.getFullYear();
            const MM = String(now.getMonth() + 1).padStart(2, '0');
            const DD = String(now.getDate()).padStart(2, '0');
            const hh = String(now.getHours()).padStart(2, '0');
            const mm = String(now.getMinutes()).padStart(2, '0');
            const ss = String(now.getSeconds()).padStart(2, '0');
            return `${YYYY}${MM}${DD}-${hh}${mm}${ss}`;
        }

        /**
         * @description 异步获取图片的二进制数据和原始尺寸
         * @param {string} url - 图片的URL
         * @returns {Promise<{buffer: ArrayBuffer, width: number, height: number}>} 包含图片buffer和尺寸的对象
         */
        function getImageData(url) {
            return new Promise(async (resolve, reject) => {
                try {
                    // 1. 使用fetch API获取图片数据
                    const response = await fetch(url);
                    if (!response.ok) reject(new Error(`HTTP请求错误! 状态码: ${response.status}`));
                    const buffer = await response.arrayBuffer();

                    // 2. 将图片数据加载到Image对象中，以获取其原始宽高
                    const blob = new Blob([buffer]);
                    const objectURL = URL.createObjectURL(blob);
                    const img = new Image();
                    img.onload = () => {
                        resolve({
                            buffer: buffer,
                            width: img.naturalWidth,
                            height: img.naturalHeight
                        });
                        URL.revokeObjectURL(objectURL); // 释放内存
                    };
                    img.onerror = () => {
                        reject(new Error('无法加载图片以获取其尺寸'));
                        URL.revokeObjectURL(objectURL);
                    };
                    img.src = objectURL;

                } catch (e) {
                    reject(e);
                }
            });
        }

        /**
         * @description 主处理函数，当用户点击“开始处理”时触发
         */
        async function handleFileProcessing() {
            // 检查用户是否已选择文件
            if (fileInput.files.length === 0) {
                const errorTips = document.getElementById('noFileError');
				// 1. 当没有选择文件时，以红色字体显示提示
                errorTips.textContent = '请先选择一个文件！';
                setTimeout(() => {
                    errorTips.textContent = '';
                }, 500); // 2秒后自动消失
                return; // 终止函数执行
            }

            // --- UI初始化：禁用按钮，显示初始状态 ---
            processButton.disabled = true;
            updateStatus('开始准备处理...', 'info');

            const file = fileInput.files[0];
            const reader = new FileReader(); // 使用FileReader读取本地文件

            // 当文件读取完成后执行
            reader.onload = async (e) => {
                const arrayBuffer = e.target.result; // 获取文件的ArrayBuffer数据
                let successCount = 0;
                let failureCount = 0;

                try {
                    // --- Excel文件操作 ---
                    updateStatus('正在读取和解析XLSX文件...', 'info');
                    const workbook = new ExcelJS.Workbook();
                    await workbook.xlsx.load(arrayBuffer);

                    const worksheet = workbook.getWorksheet(1); // 获取第一个工作表
                    if (!worksheet) throw new Error("文件中找不到任何工作表。");
                    
                    // 3. 设置冻结第1行
                    worksheet.views = [{ state: 'frozen', ySplit: 1 }];

                    // 2. 处理B列内容之前，将超链接转为文本
                    worksheet.getColumn(2).eachCell((cell, rowNumber) => {
                        if (rowNumber > 1 && cell.value && typeof cell.value === 'object' && cell.value.hyperlink) {
                            cell.value = cell.value.hyperlink;
                        }
                    });

                    // --- 数据收集与预处理 ---
                    const rowsToProcess = [];
                    // 从第2行开始遍历B列，收集所有非空单元格
                    worksheet.getColumn(2).eachCell({ includeEmpty: false }, (cell, rowNumber) => {
                        if (rowNumber > 1) {
                            rowsToProcess.push({ row: rowNumber, cell: cell });
                        }
                    });

                    if (rowsToProcess.length === 0) {
                        updateStatus('在B列（第2行及之后）没有找到任何非空单元格。', 'warning');
                        processButton.disabled = false;
                        return;
                    }
                    
                    // --- 设置单元格尺寸 (3cm) ---
                    updateStatus('正在调整单元格尺寸...', 'info');
                    // ExcelJS中，行高单位是 'points' (1 cm ≈ 28.35 points)。 3cm ≈ 85 points.
                    worksheet.getColumn(2).width = 15; // 列宽单位是 '标准字符宽度'. 3cm 约等于 15.
                    rowsToProcess.forEach(item => {
                        const row = worksheet.getRow(item.row);
                        row.height = 85;
                    });


                    // --- 核心逻辑：循环处理每一行的图片链接 ---
                    for (let i = 0; i < rowsToProcess.length; i++) {
                        const item = rowsToProcess[i];
                        const url = item.cell.value?.toString().trim(); // 获取URL并去除首尾空格
                        const progressText = `[${i+1}/${rowsToProcess.length}] 正在处理第 ${item.row} 行...`;
                        updateStatus(progressText, 'info');

                        // 检查单元格内容是否是有效的URL
                        if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
                            try {
                                const imageData = await getImageData(url); // 异步获取图片数据和尺寸
                                const imageId = workbook.addImage({ // 将图片添加到工作簿
                                    buffer: imageData.buffer,
                                    extension: 'png',
                                });

                                // 计算等比例缩放后的尺寸以适应 3x3 cm
                                const targetSizeInPixels = 113; // 3cm 在96DPI下约113像素
                                const ratio = Math.min(targetSizeInPixels / imageData.width, targetSizeInPixels / imageData.height);
                                
                                // 将图片插入工作表并应用缩放
                                worksheet.addImage(imageId, {
                                    tl: { col: 1, row: item.row - 1 }, // tl: top-left, B列=col 1, row是0-based
                                    ext: { width: imageData.width * ratio, height: imageData.height * ratio }
                                });

                                item.cell.value = null; // 清空原单元格的URL文本
                                successCount++; // 成功计数+1

                            } catch (imgError) {
                                failureCount++; // 失败计数+1
                                console.warn(`跳过第 ${item.row} 行:`, imgError);
                            }
                        } else {
                            failureCount++; // 非有效链接，失败计数+1
                        }
                    }

                    // --- 结果生成与反馈 ---
                    updateStatus('所有行处理完毕，正在生成新的XLSX文件...', 'info');
                    const newBuffer = await workbook.xlsx.writeBuffer(); // 将修改后的工作簿写入buffer
                    const blob = new Blob([newBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    
                    // 创建下载链接
                    const objectURL = URL.createObjectURL(blob);
                    const originalFileName = file.name.substring(0, file.name.lastIndexOf('.'));
                    const originalFileExt = file.name.substring(file.name.lastIndexOf('.'));
                    const newFileName = `${getFormattedDateTime()} ${originalFileName} [已处理]${originalFileExt}`;

                    downloadLinkContainer.innerHTML = `<a href="${objectURL}" download="${newFileName}">下载处理好的文件</a>`;
                    
                    // 生成最终的总结报告
                    const summaryMessage = `处理完成！${successCount}/${rowsToProcess.length} 图片链接已补全，${failureCount} 个链接无效或处理失败！`;
                    updateStatus(summaryMessage, 'success');

                } catch (error) {
                    // --- 统一错误处理 ---
                    console.error('处理过程中发生严重错误:', error);
                    updateStatus(`发生严重错误：\n${error.message}`, 'error');
                } finally {
                    // --- 流程结束，无论成功或失败，都重新启用按钮 ---
                    processButton.disabled = false;
                }
            };

            // 文件读取失败时的处理
            reader.onerror = () => {
                 updateStatus(`读取文件失败：\n${reader.error}`, 'error');
                 processButton.disabled = false;
            };

            // 启动文件读取
            reader.readAsArrayBuffer(file);
        }

        /**
         * @description 更新页面上的状态信息显示
         * @param {string} message - 要显示的消息
         * @param {string} type - 消息类型 ('info', 'success', 'error', 'warning')，用于控制样式
         */
        function updateStatus(message, type) {
            statusDiv.style.display = 'block';
            statusDiv.textContent = message;
            statusDiv.className = type; 
        }
    </script>

</body>
</html>
